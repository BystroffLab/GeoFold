!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! FORTRAN90 Rewrite of Geofold (GeoFold2)
! by Chris Bystroff, Suzanne Matthews
! Latest version: 
! Fri Apr  4 21:26:09 EDT 2008
!--------------
! Based on GEOFOLD by Saeed Salem, 
! Vibin Ramakrishnan, Chris Bystroff and Mohammed Zaki
! 2007
!-------------
! Based on UNFOLD, by Mohammed Zaki, Vinay Nadimpaly, 
! Deb Bardham, and Chris Bystroff
! 2005
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!====================================================================================
!! MODIFICATIONS:
!!  2-JUL-2008  Forced melting of left-over intermediates  C.B.
!!
!!  8-NOV-2008  Read and save H-bond donor acceptor list
!!              Modified to keep more strict '_'-based object naming.
!!  
!!  Wed Mar 25 17:04:12 EDT 2009 Calculate masker energy as a
!!              sorting element for selecting pivots, hinges, breaks,
!!              after passing the entropy cutoff.  C.B.
!!  Thu May 21 21:36:26 PDT 2009
!!              Command line changes. Parameter file is used to read
!!              file names and entropy cutoff values.  C.B.
!!  Mon May  3 11:06:29 EDT 2010
!!              Outputs SEQUENCE line to DAG file. C.B.
!!  Tue Jun 4 2013  Adding SEAMS. Additions by Luis Garreta.
!!  Fri Jun 5 2012: Adding SEAMS module, and read_seams. L.G.
!!  Thu Aug 1 2013 Bug fixes in seam energies. C.B.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
PROGRAM geofold2 
  USE geofold_global    !! geofold_global.f90
  USE geofold_pivots    !! geofold_pivots.f90
  USE geofold_masker    !! geofold_global.f90
  USE geofold_hbonds    !! geofold_global.f90
  USE geofold_seams     !! seams/geofold_seams.f90

  implicit none
  INTEGER :: nres, ierr !number of residues
  CHARACTER, dimension(:), allocatable:: chainid !gets passed in 
  CHARACTER(len=200) :: aline
  ! CHARACTER :: chainID
  INTEGER :: ires, i, j, jarg, ios, ivoid,dunit
  CHARACTER(len=200) :: filename=" ",dagfile=" ",parfile=" ",cmfile=" ",hbfile=" ",seamfile=" "
  type(intermediate), POINTER :: gptr          ! points to the global intermediate
  type(intermediate), TARGET :: Native
  ! character(len=3) :: aa
  !------------------------------ COMMAND LINE ----------------
  ires = 0
  jarg = iargc() ! get the number of command line arguments
  IF ( jarg < 3 ) THEN
     write(*,*) "Usage: xgeofold <input PDB> <output DAG> <parameter file>"
     ! write(*,*) "Usage: xgeofold <inputpdb> <mas file> <hbond file> <outputdag> [<minhinge> <minpivot> <minbreak>]" ! write usage line
     write(*,*) "<inputpdb> Pre-processed input coordinates in PDB format (xGetChain), including Void atoms(Voidmask)."
     write(*,*) "<outputdag> Output directed acyclic graph, for input to xUnfoldSim"
     write(*,*) "<parameter file> Keyworded file containing the following keywords (others keywords ignored)"
     write(*,*) "  CONTACTS <filename> -- Buried surface areas from Masker program ContactMask.f90"
     write(*,*) "  HBONDS <Hbond file> H-bond file from the utility pdb2hb.f90"
     write(*,*) "  HINGECUT <hcutoff> Minimum possible hinge rotation as a fraction of", 2*MAXHINGEANG, &
                "   degrees. default=",hcutoff," [optional]"
     write(*,*) "  PIVOTCUT <pcutoff> Minimum number of possible pivot axes as a fraction of", NVB,&
                "   default=",pcutoff," [optional]"
     write(*,*) "  BREAKCUT <bcutoff> Minimum number of possible translation vectors as a fraction of", NVB,&
                " default=",bcutoff," [optional]"
     write(*,*) "  SEAMCUT <scutoff> Minimum number of possible translation vectors as a fraction of", NVB,&
                " default=",scutoff," [optional]"
     write(*,*) "  MAXSPLIT <n> n={2,4,6,8} is the maximum number of children for each parent."
     write(*,*) "  default=",maxsplit
     write(*,*) "  MINSEG <n> n={2..20} is the Minimum size of a terminal fragment to unfold."
     write(*,*) "  default=",pivottail
     stop 'geofold.f90 v.  Wed Sep 30 12:00:57 EDT 2009'
  END IF
  call getarg(1, filename) ! get the name of input pdb from command line
  call getarg(2, dagfile) ! get the name of output file
  call getarg(3, parfile) ! get the name of parameters file
  !!=============== READ PARAMETERS FILE ================
  dunit = pickunit(20)
  open(dunit,file=parfile,status='old',form='formatted',iostat=ios)
  if (ios/=0) stop 'geofold.f90:: parameters file not found.'
  aline = " "
  do
    read(dunit,'(a)',iostat=ios) aline
    if (ios/=0) exit
    select case (aline(1:index(aline,' ')-1))
    case ("HINGECUT","hingecut")
      read(aline(index(aline,' '):),*,iostat=ios) hcutoff
      if (ios/=0) STOP 'geofold.f90:: bad value for HINGECUT'
      if (hcutoff>1.0) stop "Bad value for HINGECUT. Must be real number between 0 and 1.0"
      if (hcutoff<0.) stop "Bad value for HINGECUT. Must be real number between 0 and 1.0"
      write(*,'("HINGECUT ",f7.3)') hcutoff
    case ("PIVOTCUT","pivotcut")
      read(aline(index(aline,' '):),*,iostat=ios) pcutoff
      if (ios/=0) STOP 'geofold.f90:: bad value for PIVOTCUT'
      if (pcutoff>1.0) stop "Bad value for PIVOTCUT. Must be real number between 0 and 1.0"
      if (pcutoff<0.) stop "Bad value for PIVOTCUT. Must be real number between 0 and 1.0"
      write(*,'("PIVOTCUT ",f7.3)') pcutoff
    case ("BREAKCUT","breakcut")
      read(aline(index(aline,' '):),*,iostat=ios) bcutoff
      if (ios/=0) STOP 'geofold.f90:: bad value for BREAKCUT'
      if (bcutoff>1.0) stop "Bad value for BREAKCUT. Must be real number between 0 and 1.0"
      if (bcutoff<0.) stop "Bad value for BREAKCUT. Must be real number between 0 and 1.0"
    !! nseam should be set to maxsplit.  --cb
    ! case ("SEAMCUT","nseam")
    !  read(aline(index(aline,' '):),*,iostat=ios) nseam
    !  if (ios/=0) STOP 'geofold.f90:: bad value for SEAMCUT'
    !  if (nseam>maxsplit) STOP 'geofold.f90:: SEAMCUT must be <= maxsplit=8'
    !  write(*,'("SEAMCUT ", I5)') nseam
    !  write(*,'("SEAMCUT ", I5)') nseam
    case ("CONTACTS","contacts")
      cmfile = trim(adjustl(aline(index(aline,' '):)))
      write(*,'("CONTACTS ",a)') trim(cmfile)
    case ("HBONDS","hbonds")
      hbfile = trim(adjustl(aline(index(aline,' '):)))
      write(*,'("HBONDS ",a)') trim(hbfile)
    case ("SEAMS","seams")
      seamfile = trim(adjustl(aline(index(aline,' '):)))
      write(*,'("SEAMS ",a)') trim(seamfile)
    case ("MINSEG","minseg")
      read(aline(index(aline,' '):),*,iostat=ios) pivottail
      if (ios/=0) STOP 'geofold.f90:: bad value for MINSEG'
      write(*,'("MINSEG ",i3)') pivottail
    case ("MAXSPLIT","maxsplit")
      read(aline(index(aline,' '):),*,iostat=ios) maxsplit
      if (ios/=0) STOP 'geofold.f90:: bad value for MAXSPLIT'
      write(*,'("MAXSPLIT ",i3)') maxsplit
    case ("VERBOSE","verbose")
      read(aline(index(aline,' '):),*,iostat=ios) i
      if (ios/=0) STOP 'geofold.f90:: bad value for VERBOSE'
      verbose = (i>0)
      write(*,'("VERBOSE ",L1)') verbose
    case default
    end select 
  enddo
  if (cmfile==" ") stop 'geofold.f90:: no value for CONTACTS file in parameters file'
  if (hbfile==" ") stop 'geofold.f90:: no value for HBONDS file in parameters file'
  if (seamfile==" ") stop 'geofold.f90:: no value for SEAMS file in parameters file'
  close(dunit)
  write(*,'("!------------------------------ READ INPUT PDB FILE ---------")')
  dunit = pickunit(10)
  open(dunit, file=filename, form="formatted", status="old", iostat=ierr)
  IF (ierr > 0 ) STOP "geofold:: Error! File not found!"
  call geofold_readpdb(dunit)
  call geofold_masker_readvoids(dunit)
  close(dunit)
  write(*,'("!------------------------------ INITIALIZE   ----------------")')
  nres = geofold_nres 
  Native%iflag = masterchains  
  Native%idnum = 1
  Native%state = 1 
  Native%axis = 0  
  Native%barrel = 0
  NULLIFY(Native%next)
  gptr => Native
  nullify(ilistroot)

  CALL geofold_initpivot(allcoords,nres,chainid=masterchains)
  CALL geofold_masker_setvoids()
  call geofold_masker_read(cmfile)
  call geofold_hbonds_read(hbfile)

  call geofold_seams_read(seamfile)
  write(*,'("!------------------------------ UNFOLD   ----------------")')
  call getcutpoints(gptr)
  write(*,'("!------------------------------ FINISH UP   ----------------")')
  call writefile4unfoldsim(dagfile,ounit=dunit) 
  call writeBarrels (ounit=dunit)
  close(dunit)
  call cleanuplists()
CONTAINS

!!====================================================================================

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!subroutine getcutpoints
!takes a folded portion of protein
!recurses until unfolded
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

RECURSIVE SUBROUTINE getcutpoints( f )
  !! ------- cut point algorithm ---------
  !! 
  !! If the intermediate is multichain, break if possible.
  !! If not, then if the chain(s) is long enough, pivot if possible.
  !! If not, then if the chain is long enough, hinge if possible.
  !! If not, then if barrels are present, then seam if possible.
  !! If not, if the chain is greater than length 1, then melt
  !! If not, then it is length 1, return.
  !!
  implicit none
  type(intermediate), POINTER :: f
  type(intermediate), target :: child1, child2
  type(intermediate), pointer :: u1, u2
  INTEGER :: lastpos,lastbreak,lasthinge
  INTEGER :: interval
  INTEGER :: flag,ios=0
  INTEGER :: cuttype, nchain, nres, mres, nseam
  integer :: nbreak,ibreak,npivot,ipivot,nhinge,ihinge, iseam, nmove
  REAL :: entropy
  ! logical,optional,intent(out) :: done
  ! logical :: u1done,u2done
  character,dimension(MAXCHAIN) :: uniqchains
  type(intermediate),dimension(:),allocatable :: allu1
  real,dimension(:),allocatable :: allentropy
  type (seammove_type), pointer :: seammove (:)

  write(*,*) "Getting cutpoints"
  call printf(f)
  !-----------
  nullify(u1, u2)
  if (allocated(allentropy)) deallocate(allentropy)
  allocate(allentropy(maxsplit+1),stat=ios)
  if (ios/=0) stop 'geofold:: getcutpoints: error allocating allentropy'
  if (allocated(allu1)) deallocate(allu1)
  allocate(allu1(maxsplit+1),stat=ios)
  if (ios/=0) stop 'geofold:: getcutpoints: error allocating allu1'
  nres = geofold_nres
  if (.not. associated(f)) then
    write(0,'("Warning: called getcutpoints with an unassociated pointer!!")')
    stop 'Warning: called getcutpoints with an unassociated pointer'
  endif
  interval = oldintermediate(f)
  !diagnostic
  if (verbose) then
     if (interval==0) then
       WRITE (0,*) 'in getcutpoints:: NO oldintermediate found for ',f%idnum
     else
       WRITE (0,*) 'in getcutpoints:: oldintermediate number = ', interval
       f%idnum = interval
     endif
  endif
  f%idnum = interval
  IF (interval /= 0 )  RETURN
  IF ( count(f%iflag(1:geofold_nres) /= '.') == 0 ) RETURN ! empty
  !!---- CYCLE FROM HERE as long as no cutpoints can be found
  ! CUTOFFLOOP: DO
  !!---- if intermediate is too small, melt it.
  call getallchains(f%iflag,uniqchains(1:nres),nchain,nres)  !! returns chain chars in uniqchains
  mres = count(f%iflag(1:geofold_nres) /= '.')
  if (nchain==1.and.mres<=(2*pivottail+3)) then
    call getmelting(f)
    return
  endif
  CALL saveintermediate(f)
  IF ( count(f%iflag(1:geofold_nres) /= '.') == 1 ) RETURN     ! leaf node
  !! ---- two new children are created for each recursion depth ----
  u1 => child1
  u2 => child2
  u1%idnum = 0
  u2%idnum = 0
  u1%state = f%state + 1    ! recursion depth
  u2%state = f%state + 1    ; if (f%state > 5000) stop 'geofold:: getcutpoints: RECURSION DEPTH LIMIT EXCEEDED!!!'
  u1%iflag = '.'
  u2%iflag = '.'
  u1%axis = 0
  u2%axis = 0
  u1%barrel=f%barrel
  u2%barrel=f%barrel
  NULLIFY(u1%next)
  NULLIFY(u2%next)
  !! Split the pathway 
  geofold_split = nint(real(maxsplit)/(f%state / FULSPLITDEPTH ) )
  if (geofold_split==0) geofold_split = 1
  if (geofold_split>maxsplit) geofold_split = maxsplit
  !!------------- BREAKS ----------------
  call getbreaks(f,allu1,allentropy,nbreak)
  if (verbose.and.nbreak > 0) write(*,*) '============>>> found ',nbreak,' BREAKs'
  breakloop: DO ibreak=1,nbreak
     entropy = allentropy(ibreak)
     u1%iflag = allu1(ibreak)%iflag
     f%axis = allu1(ibreak)%axis
     CALL getcutpoints(u1)   !!  recusrively find cutpoints
     u2%iflag = f%iflag
     where (u1%iflag/='.') u2%iflag = '.'
     CALL getcutpoints(u2)
     cuttype = breakflag
     CALL savetstate(f,u1,u2=u2,t=cuttype, ent=entropy)
  enddo breakloop
  if (nbreak > 0) return
  !!------------- PIVOTS ----------------
  call getpivots(f,allu1,allentropy,npivot)
  if (verbose.and.npivot > 0) write(*,*) '============>>> found ',npivot,' PIVOTS'
  pivotloop: DO ipivot=1,npivot 
     entropy = allentropy(ipivot)
     u1%iflag = allu1(ipivot)%iflag
     f%axis = allu1(ipivot)%axis
     CALL getcutpoints(u1)   !!  recusrively find cutpoints
     u2%iflag = f%iflag
     where (u1%iflag/='.') u2%iflag = '.'
     CALL getcutpoints(u2)
     cuttype = pivotflag
     CALL savetstate(f,u1,u2=u2,t=cuttype, ent=entropy)
  enddo pivotloop
  if (npivot > 0) return
  !!------------- SEAMS  ----------------
  !!-1: left, 1: right  --> allside
  if (associated(seammove)) deallocate(seammove)
  nseam = maxsplit
  allocate(seammove(nseam),stat=ios); if (ios/=0) stop 'geofold:: getcutpoints: error allocating seammove.'
  seammove(:)%barrel=0;seammove(:)%seam=0;seammove(:)%energy=0;seammove(:)%side=0;
  call getseams(f, seammove, nseam) 
  if (verbose.and.nseam > 0) then
     write(*,*) '============>>> found ',nseam,' SEAMS'
     do iseam=1,nseam
       write(*,*) seammove(iseam)%barrel, seammove(iseam)%seam, seammove(iseam)%side, seammove(iseam)%energy
     enddo
  endif
  seamloop: DO iseam=1,nseam
     if (seammove(iseam)%barrel==0) cycle
     if (seammove(iseam)%barrel<0) then
       write(0,'("ERROR: seammove(",i3,")%barrel=",i3)') iseam,seammove(iseam)%barrel
       stop "geofold.f90:: error in seamloop."
     endif
     entropy = seammove(iseam)%energy  !! contact energy
     u1%iflag = f%iflag
     u1%barrel(seammove(iseam)%barrel) = seammove(iseam)%seam * seammove(iseam)%side !! set flag
     ! write(*,*) "seamloop:: u1%barrel(seammove(",iseam,")%barrel)=",u1%barrel(seammove(iseam)%barrel)
     CALL getcutpoints(u1)   !!  recusrively find cutpoints
     cuttype = seamflag
     CALL savetstate(f,u1,t=cuttype, ent=entropy, iseam=u1%barrel(seammove(iseam)%barrel)) !! add to list of intermediates
  enddo seamloop
  if (associated(seammove)) deallocate(seammove)
  if (nseam > 0) return
  !!------------- HINGES  ----------------
  call gethinges(f,allu1,allentropy,nhinge)
  if (verbose.and.nhinge > 0) write(*,*) '============>>> found ',nhinge,' HINGES'
  hingeloop: DO ihinge=1,nhinge
     entropy = allentropy(ihinge)
     u1%iflag = allu1(ihinge)%iflag
     f%axis = allu1(ihinge)%axis
     CALL getcutpoints(u1)   !!  recusrively find cutpoints
     u2%iflag = '.'
     where (f%iflag/='.'.and.u1%iflag=='.') u2%iflag = f%iflag
     CALL getcutpoints(u2)
     cuttype = hingeflag
     CALL savetstate(f,u1,u2=u2,t=cuttype, ent=entropy)
  enddo hingeloop
  if (nhinge > 0) return
  !!------------- MELT    ----------------
  ! WRITE (*,*) 'ERROR: No cutpoints found for ',f%iflag(1:geofold_nres)
  ! stop 'geofold:: BUG or ERROR. No cutpoints found. '
  WRITE(*,*) 'WARNING: No cutpoints found for ',f%iflag(1:geofold_nres)
  if (any(f%barrel(:)/=0)) write(*,*) "NOTE: It is an open barrel."
  WRITE(*,*) 'MELTING it.'
  call getmelting(f,force=.true.)
  return
END SUBROUTINE getcutpoints

!!====================================================================================

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!function getbreaks
!Attempts to find chains tht can separate
!by simple translation.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE getbreaks(f,allu1,allentropy,nbreak)
  integer,intent(out) :: nbreak
  type(intermediate), POINTER :: f
  type(intermediate),dimension(:),intent(out) :: allu1   !! changed to assumed-shape 5/3/10
  real,dimension(:),intent(out) :: allentropy   !! changed to assumed-shape 5/3/10
  type(intermediate),pointer :: u1, u2
  character,dimension(MAXCHAIN) :: uniqchains
  real,dimension(:),allocatable :: allenergy
  real :: entropy, energy, fenergy, u1energy, u2energy
  integer :: ires, nchain, nres, bpoint, ibreak, mbreak, nsplit, bvec, i, j, ios
  if (allocated(allenergy)) deallocate(allenergy)
  allocate(allenergy(geofold_split+1),stat=ios); if (ios/=0) stop 'geofold:: getbreaks: BUG allocating allenergy'
  call geofold_masker_energy(f,fenergy)
  allocate(u1,u2,stat=ios); if (ios/=0) stop 'geofold:: error allocating u1,u2 in getpivots'
!  call printf(f)
  call zerointermediate(u1)
  call zerointermediate(u2)
  call zerointermediate(allu1)
  entropy = 0.
  nbreak = 0
  bvec = 0
  nres = geofold_nres
  call getallchains(f%iflag,uniqchains,nchain,nres)  !! returns chain chars in uniqchains
  if (nchain <= 1) then
    deallocate(u1,u2)
    return
  endif
  mbreak = 2**(nchain-2)
  bpoint = 0
  nullify(u1%next, u2%next)
  nsplit = geofold_split
  allenergy = -99999999.
  allentropy = 0.
  do while (bpoint<mbreak)
    call geofold_getnextbreak(f=f,calpha=allcoords,chainid=f%iflag,u1=u1%iflag,u2=u2%iflag, &
                            nres=nres,breakpoint=bpoint,entropy=entropy,bvec=bvec)
    if (entropy>bcutoff) then
      call geofold_masker_energy(u1,u1energy)
      call geofold_masker_energy(u2,u2energy)
      energy = u1energy + u2energy - fenergy
      if (nbreak<nsplit) nbreak = nbreak + 1
      ibreak = nbreak + 1
      !!do while (entropy>allentropy(ibreak-1))
      do while (energy>allenergy(ibreak-1))
        allenergy(ibreak) = allenergy(ibreak-1)
        allentropy(ibreak) = allentropy(ibreak-1)
        allu1(ibreak)%iflag = allu1(ibreak-1)%iflag
        allu1(ibreak)%axis = allu1(ibreak-1)%axis
        ibreak = ibreak - 1
        if (ibreak==1) exit
      enddo
      allenergy(ibreak) = energy
      allentropy(ibreak) = entropy
      allu1(ibreak)%iflag = u1%iflag
      allu1(ibreak)%axis = bvec
    endif
  enddo
  deallocate(u1,u2)
  deallocate(allenergy)
END SUBROUTINE getbreaks

!!====================================================================================
! get pivots finds positions within the chain that permit
! free rotation of the N-term versus the C-term
! Separate chains are distributed to N or C-term all possible ways.
!
SUBROUTINE getpivots(f,allu1,allentropy,npivot)
  implicit none
  integer,intent(out) :: npivot
  type(intermediate), POINTER :: f
  type(intermediate),dimension(:),intent(out) :: allu1   !! assumed shape 5/3/10
  real,dimension(:),intent(out) :: allentropy   !! assumed shape 5/3/10
  type(intermediate),pointer :: u1, u2
  ! character,dimension(MAXCHAIN) :: uniqchains
  real :: entropy, energy, fenergy, u1energy, u2energy
  real,dimension(:),allocatable :: allenergy
  integer :: ires, nchain, nres, bpoint, ipivot,nsplit, bvec, ios
  !!
  allocate(allenergy(geofold_split+1),stat=ios); if (ios/=0) stop 'geofold:: getpivots: BUG allocating allenergy'
  call geofold_masker_energy(f, fenergy)
  entropy = 0.
  npivot = 0
  nres = geofold_nres
  bpoint = 0
  allocate(u1,u2,stat=ios); if (ios/=0) stop 'geofold:: error allocating u1,u2 in getpivots'
  call zerointermediate(allu1)
  call zerointermediate(u1)
  call zerointermediate(u2)
  nsplit = geofold_split
  allentropy = 0.
  allenergy = -99999999.
  bvec = 0
  do while (bpoint<nres)
    call geofold_getnextpivot(f=f,calpha=allcoords,chainid=f%iflag,u1=u1%iflag,u2=u2%iflag, &
                             nres=nres,pivotpoint=bpoint,entropy=entropy,bvec=bvec)
    if (entropy<pcutoff) then
      deallocate(u1,u2)
      return
    endif
    call geofold_masker_energy(u1,u1energy)
    call geofold_masker_energy(u2,u2energy)
    energy = u1energy + u2energy - fenergy
    if (entropy>pcutoff) then
      if (npivot<nsplit) npivot = npivot + 1
      ipivot = npivot + 1
      !!do while (entropy>allentropy(ipivot-1))
      do while (energy>allenergy(ipivot-1))
        allentropy(ipivot) = allentropy(ipivot-1)
        allenergy(ipivot) = allenergy(ipivot-1)
        allu1(ipivot)%iflag = allu1(ipivot-1)%iflag
        allu1(ipivot)%axis = allu1(ipivot-1)%axis
        ipivot = ipivot - 1
        if (ipivot==1) exit
      enddo
      allenergy(ipivot) = energy
      allentropy(ipivot) = entropy
      allu1(ipivot)%iflag = u1%iflag 
      allu1(ipivot)%axis = bvec
    endif
  enddo
  deallocate(u1,u2)
  deallocate(allenergy)
END SUBROUTINE getpivots
!!====================================================================================
! gethinges attempts to find pairs of positions in the
! same chain that permit the rotation around the
! hinge axis of the segment between the hine points.
!
SUBROUTINE gethinges(f,allu1,allentropy,nhinge)
  integer,intent(out) :: nhinge
  type(intermediate), POINTER :: f
  type(intermediate),dimension(:),intent(out) :: allu1   !! assumed shape 5/3/10
  real,dimension(:),intent(out) :: allentropy   !! assumed shape 5/3/10
  real :: energy, fenergy, u1energy, u2energy
  real,dimension(:),allocatable :: allenergy
  type(intermediate),pointer :: u1, u2
  character,dimension(MAXCHAIN) :: uniqchains
  real :: entropy, mat(3)
  integer :: ires, nchain, nres, bpoint, ihinge, nsplit
  integer :: lasti, lastj
  if (allocated(allenergy)) deallocate(allenergy)
  allocate(allenergy(geofold_split+1),stat=ios); if (ios/=0) stop 'geofold:: gethinges: BUG allocating allenergy'
!  call printf(f)
  call geofold_masker_energy(f, fenergy)
  entropy = 0.
  nhinge = 0
  nres = geofold_nres
  bpoint = 0
  allocate(u1,u2,stat=ios); if (ios/=0) stop 'geofold:: error allocating u1,u2 in gethinges'
  call zerointermediate(allu1)
  call zerointermediate(u1)
  call zerointermediate(u2)
  nsplit = geofold_split
  lasti = 1
  lastj = 0
  allentropy = 0.
  allenergy = -99999999.
  allu1(:)%axis = 0
  do while (lasti<nres)
   call geofold_getnexthinge(f=f,calpha=allcoords,chainid=f%iflag,u1=u1%iflag,u2=u2%iflag, &
                             nres=nres,hinge1=lasti,hinge2=lastj,entropy=entropy)
    if (entropy<hcutoff) then
      deallocate(u1,u2)
      return
    endif
    if (entropy>hcutoff) then
      call geofold_masker_energy(u1,u1energy)
      call geofold_masker_energy(u2,u2energy)
      energy = u1energy + u2energy - fenergy
      if (nhinge<nsplit) nhinge = nhinge + 1
      ihinge = nhinge + 1
      !!do while (entropy>allentropy(ihinge-1))
      do while (energy>allenergy(ihinge-1))
        allenergy(ihinge) = allenergy(ihinge-1)
        allentropy(ihinge) = allentropy(ihinge-1)
        allu1(ihinge)%iflag = allu1(ihinge-1)%iflag
        allu1(ihinge)%axis = allu1(ihinge-1)%axis
        ihinge = ihinge - 1
        if (ihinge==1) exit
      enddo
      allenergy(ihinge) = energy
      allentropy(ihinge) = entropy
      !! NOTE: we use u2 from geofold_getnexthinge because it has new flags, 
      !! while u1 retains flags from f. New flags are needed in calling
      !! routine, getcutpoints.
      allu1(ihinge)%iflag = u2%iflag
      !! watch out. tricky business: store residue numbers for hinge in "axis" element.
      allu1(ihinge)%axis = 10000*lasti + lastj
    endif
  enddo
  deallocate(u1,u2)
  deallocate(allenergy)

END SUBROUTINE gethinges
!---------------------------------------------------------------------------------
! getseams attempts ...
!  call getseams(f,allbarrel,allseam,allentropy,nseam) 
!---------------------------------------------------------------------------------
subroutine getseams (f, seammove, nMove)
	implicit none
	  	type (intermediate), POINTER         :: f
	  	type (seammove_type), pointer        :: seammove (:)
	  	integer,intent (inout)               :: nMove
	  	integer                              :: nBarrels, iBarrel, nseams, iSeam, i, side, nseam
	  	type (seammove_type)                 :: tmpMove
	  	real                                 :: energy
		CHARACTER, dimension(1600) :: flags     ! flags that define the intermediate
		
!		call printf(f)

	seammove(:)%energy = HUGE(0.0)
	nseam = nMove
	nMove = 0
    side = 0

	nBarrels = size (barrels_array)
    if (nBarrels==0) return
	do iBarrel=1, nBarrels
		if (f%barrel(iBarrel) /= 0) cycle  !! open
        !! diagnstic
        !write(*,*) 'Number of seams for barrel',iBarrel, ' = ', barrels_array(iBarrel)%nseams
		do iSeam=1, barrels_array(iBarrel)%nseams
			flags = f%iflag
			energy = getEnergySeam(cmfile,geofold_nres,iBarrel,iSeam,side,flags)
            !! diagnostic
            write(*,*) 'Seam ',iSeam, ' getEnergySeam returned ',energy
			if (energy == 0) cycle  ! no seam
			tmpMove%barrel = iBarrel
			tmpMove%seam   = iSeam
			tmpMove%energy = energy
			tmpMove%side   = side
            if (energy < maxval(seammove(1:nseam)%energy,dim=1)) then
              i = maxloc(seammove(1:nseam)%energy,dim=1)
              seammove(i) = tmpMove
              nMove = nMove + 1
            endif
		enddo
	enddo
    if (nMove > nseam) nMove = nseam
endsubroutine getseams
!!====================================================================================
! getmelting divides a short segment into
! smaller pieces until it consists of single residues.
!
recursive subroutine getmelting(f,force)
  type(intermediate), POINTER :: f
  logical,optional :: force
  type(intermediate), target :: child1, child2
  type(intermediate), pointer :: u1, u2
  type(intermediate), POINTER :: ihead
  integer :: found, i, id, n
  logical,parameter :: veryverbose=.true.
  !!
  !diagnostic
!  call printf(f)
  if (.not.associated(ilistroot)) stop 'geofold.f90:: getmelting BUG 1'
  IF ( count(f%iflag(1:geofold_nres) /= '.') == 0 ) RETURN ! empty
  id =  oldintermediate(f)
  if (id/=0) then
    f%idnum = id
     if (verbose.and.veryverbose) write(0,*) "getmelting:: Found an old intermediate ",id
    if (.not.present(force)) return
  endif
  if (id==0) call saveintermediate(f)
  IF ( count(f%iflag(1:geofold_nres) /= '.') == 1 ) RETURN !checks to see if it is a single aa
  ihead => ilistroot
  found = 0
  n = 0
  outloop: do while ( associated(ihead%next) )
     ihead => ihead%next
     n = n + 1
     if (f%idnum==ihead%idnum) cycle
     if (all((ihead%iflag(1:geofold_nres)=='.').or.(f%iflag(1:geofold_nres)/='.'))) then
       !! check to see that the first or last flag is set
       inloop1: do i=1,geofold_nres
         if (f%iflag(i)/='.') then
           if (ihead%iflag(i)/='.') then
             found = 1
             exit outloop
           else
             exit inloop1
           endif
         endif
       enddo inloop1
       inloop2: do i=geofold_nres,1,-1
         if (f%iflag(i)/='.') then
           if (ihead%iflag(i)/='.') then
             found = 1
             exit outloop
           else
             exit inloop2
           endif
         endif
       enddo inloop2
     endif
  enddo outloop
  u1 => child1
  u2 => child2
  u1%iflag = '.'
  u2%iflag = '.'
  u1%axis = 0
  u2%axis = 0
  u1%idnum = 0
  u2%idnum = 0
  u1%state = f%state + 1    ! recursion depth
  u2%state = f%state + 1
  u1%barrel = f%barrel
  u2%barrel = f%barrel
  if (found==1) then
    do i=1,geofold_nres
      u1%iflag(i) = ihead%iflag(i)
      if (f%iflag(i)/='.' .and. ihead%iflag(i)=='.') then
        u2%iflag(i) = f%iflag(i)
      endif
    enddo
    ! call getmelting(u1)  !! not necessary since u1 = ihead
  else  
      write(0,*) "Melting by one character  n= ", n
    !! no existing subsets in the intermediate list. peel one residue.
    u2%iflag = f%iflag
    do i=1,geofold_nres
       if (f%iflag(i)/='.') then
         u1%iflag(i) = f%iflag(i)
         u2%iflag(i) = '.'
         exit
       endif
    enddo
  endif
!  call getmelting(u1)
!  call getmelting(u2)
  call getcutpoints(u1)
  call getcutpoints(u2)
  call savetstate(f,u1,u2=u2,t=meltflag, ent=0.1)
  !!  
end subroutine getmelting

!!====================================================================================

!!====================================================================================
! Changed u2 to optional. For seams 
!!====================================================================================
! savetstate adds  one elemental subsystem, composed
! of segment f and segments u1 and u2, to a lnked list of
! saved transitions states.
!
SUBROUTINE savetstate(f, u1, u2, t, ent, iseam)
  implicit none
  type(intermediate), POINTER :: f, u1
  type(intermediate), POINTER, optional ::  u2
  INTEGER, intent(in) :: t
  REAL, intent(in) :: ent
  integer, optional, intent(in) :: iseam
  INTEGER, save :: tstatecounter=1
  TYPE (tstate), POINTER  :: ttail   ! declare tail of the tstate list
  character(len=5),parameter :: cuttypes="bphsm"
  if (.not. associated(f)) STOP 'save tstate: error! f not associated!'
  if (.not. associated(u1)) STOP 'save tstate: error! u1 not associated!'
  if (present(u2)) then
    if (.not. associated(u2)) STOP 'save tstate: error! u2 not associated!'
  endif
  if (f%idnum==0) then
    write(0,*) 'savetstate: error! attempting to save f%idnum=0'
    return
  endif
  if (u1%idnum==0) then
    write(0,*) 'savetstate: error! attempting to save u1%idnum=0'
    return
  endif
  if (present(u2)) then
    if (u2%idnum==0) then
      write(0,*) 'savetstate: WARNING! attempting to save u2%idnum=0, cuttype=',t
    endif
  endif
  IF (.NOT. ASSOCIATED(tlistroot)) THEN !check to see if list is empty
     ALLOCATE(tlistroot)
     NULLIFY(tlistroot%next)
  ENDIF
  ttail => tlistroot
  do while (associated(ttail%next))
     ttail => ttail%next
     if (ttail%parent/=f%idnum) cycle
     if (t==seamflag) then
       if (ttail%child1/=u1%idnum) cycle
     else
       if (ttail%child1/=u1%idnum.and.ttail%child2/=u1%idnum) cycle
       if (ttail%child1/=u2%idnum.and.ttail%child2/=u2%idnum) cycle
     endif
     !! this tstate is identical to a previous one
     if (verbose) then
       write(0,*) "savetstate:: tstate identical to previous one"
     endif
     return
  enddo
  ALLOCATE(ttail%next)
  NULLIFY(ttail%next%next)
  ttail => ttail%next
  ttail%tp = t
  ttail%id = tstatecounter
  ttail%entropy = ent
  ttail%parent = f%idnum
  ttail%child1 = u1%idnum
  ttail%child2 = 0
  if (present (u2)) ttail%child2 = u2%idnum
  ttail%axis = f%axis
  ttail%seam = 0
  if (present(iseam)) ttail%seam = iseam
  tstatecounter = tstatecounter + 1   !need tstate number
  if (verbose) then
     write(0,*) "TSTATE ", tstatecounter, ttail%parent, ttail%child1, ttail%child2, cuttypes(t:t)
  endif
END SUBROUTINE savetstate
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!subroutine saveintermediate
!saves intermediate f to a linked list
!of intermediates.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE saveintermediate(f)
  ! save a copy of f to a linked list
  ! We NOW assume that this is a new intermediate!!  Tue Aug 20 19:45:26 EDT 2013
  type(intermediate), POINTER :: f
  TYPE (intermediate), POINTER, save :: itail ! declare tail of the intermediate list
  INTEGER, save :: intercounter=1, id=0
  logical,parameter :: semiverbose=.true.
  character(len=1500) :: tmpstr
  integer :: i
  logical :: debugging=.true.
  !!--
  if (.not.associated(f)) then
     write(0,*) "saveintermediate:: BUG!  nothing to save!! "
     return
  endif
  if (debugging) then
    id = oldintermediate(f)
    if (id /= 0) then
      f%idnum = id
      write(0,*) "WARNING: FOUND AN UNEXPECTED OLD INTERMEDIATE while in saveintermediates() ..."
      return
    endif
  endif
  IF (.NOT. ASSOCIATED(ilistroot)) THEN
     ALLOCATE (ilistroot)
     NULLIFY(ilistroot%next)
     itail => ilistroot   !! empty root 
  END IF
  ALLOCATE(itail%next)
  NULLIFY(itail%next%next)
  itail => itail%next
  f%idnum = intercounter
  f%sym = countsyms(f%iflag,geofold_nres)
  itail = f
  NULLIFY(itail%next)
  if (verbose.or.semiverbose) then
     tmpstr = " "
     do i=1,geofold_nres
       tmpstr = trim(tmpstr)//f%iflag(i)
     enddo
     write(0,'(a,i4,a,a,$)') "Intermediate ",f%idnum," ",trim(tmpstr) 
     write(0,'(a,i4,$)') " depth",f%state
     if (f%sym/=0) write(0,'(a,i2,$)') " sym=",f%sym
     if (any(f%barrel(:)/=0)) write(0,'(a,$)') " seams: "
     do i=1,MAXBARREL
       if (any(f%barrel(i:)/=0)) write(0,'(i2,$)') f%barrel(i)
     enddo
     write(0,*)
  endif
  intercounter = intercounter + 1
END SUBROUTINE saveintermediate
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!print intermediates
!to stdout
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE printintermediates
  type(intermediate), POINTER :: pptr
  pptr => ilistroot
  output: DO while (associated(pptr%next) )
     pptr => pptr%next
     WRITE(*, *) 'INTERMEDIATE ', pptr%idnum, ' ', pptr%state
  END DO output
END SUBROUTINE printintermediates
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! check to see whether f is already in 
! the intermediates list. 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
INTEGER FUNCTION oldintermediate(f)
  type(intermediate), POINTER :: f
  type (intermediate), POINTER,save :: ihead
  integer :: ios=0, n = 0, i, iseam, y1,y2,x1,x2
  logical :: thesame=.false.
  if (.not.associated(f)) then
    write(0,'("Warning:: called oldintermediate(f) with an unassociated pointer!!")')
    stop "Warning:: called oldintermediate(f) with an unassociated pointer!!"
    oldintermediate = 0
    return
  endif
  if (associated(ilistroot)) then
    ihead => ilistroot
  else
    write(0,'("Warning:: oldintermediate :: head of linked list (ilistroot) is missing!!")')
    oldintermediate = 0
    return
  endif
  n = 0
  DO while ( associated(ihead%next) ) 
     ihead => ihead%next
     thesame = .false.
     IF ( checkflags(ihead%iflag,f%iflag) ) THEN
       thesame = .true.
       do i=1,MAXBARREL  !! = 8
         if ( ihead%barrel(i)/=f%barrel(i) ) then ! not the same seam
           iseam = abs(f%barrel(i))
           if (iseam /= 0) then
             y1=barrels_array(i)%seams(iseam)%segments(1)
             y2=barrels_array(i)%seams(iseam)%segments(2)
             x1=barrels_array(i)%seams(iseam)%segments(3)
             x2=barrels_array(i)%seams(iseam)%segments(4)
             if (any(f%iflag(y1:y2)/=".").and.any(f%iflag(x1:x2)/=".")) then
               thesame = .false.
             endif
           endif
           iseam = abs(ihead%barrel(i))
           if (iseam /= 0) then
             y1=barrels_array(i)%seams(iseam)%segments(1)
             y2=barrels_array(i)%seams(iseam)%segments(2)
             x1=barrels_array(i)%seams(iseam)%segments(3)
             x2=barrels_array(i)%seams(iseam)%segments(4)
             if (any(f%iflag(y1:y2)/=".").and.any(f%iflag(x1:x2)/=".")) then
               thesame = .false.
             endif
           endif
         endif
       enddo
     ENDIF
     if (thesame) then
       oldintermediate = ihead%idnum !! found old intermediate
       return
     endif
     n = n + 1
  ENDDO
  oldintermediate = 0
  if (verbose) then
     write(0,*) "New intermediate added. Number of intermediate so far =",n
  endif
  return
END FUNCTION oldintermediate
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!determine if newf, oldf are equivalent
!return true or false based on result
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
logical FUNCTION checkflags(newf, oldf)
  CHARACTER, dimension(maxres) :: newf, oldf 
  CHARACTER, dimension(maxres) :: symf
  integer :: nsym, isym, nres
  nres = geofold_nres
  nsym = geofold_nsym
  do isym=0,nsym
    call applysymmetry(isym,newf,symf,nres)
    !  if ( all(symf(1:geofold_nres) == oldf(1:geofold_nres))) then
    if ( all( ((oldf(1:geofold_nres)/='.').and.(symf(1:geofold_nres)/='.')).or. &
              ((oldf(1:geofold_nres)=='.').and.(symf(1:geofold_nres)=='.')) ) ) then
      checkflags = .true.
      return
    endif
  enddo
  checkflags = .false.
END FUNCTION checkflags
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! countsyms()
! count how many syms there are of a given intermediate
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
integer FUNCTION countsyms(flags,nres)
  integer,intent(in) :: nres
  CHARACTER, dimension(nres),intent(in) :: flags
  CHARACTER, dimension(nres) :: symf
  integer :: isym, nn, nsym
  nn = 0
  nsym = geofold_nsym
  do isym=1,nsym
    call applysymmetry(isym,flags,symf,nres)
    if ( .not. any((flags/='.').and.(symf/='.'))) then
      nn = nn + 1
    endif
  enddo
  countsyms = nn
END FUNCTION countsyms
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Apply symmetry operators
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
subroutine applysymmetry(isym,f,symf,nres)
  ! use geofold_pivots, only : geofold_symop
  implicit none
  integer,intent(in) :: isym, nres
  character, dimension(nres), intent(in) :: f
  character, dimension(nres) , intent(out):: symf
  integer :: i
  !!
  if (isym==0) then
    symf(1:nres) = f(1:nres)
    return
  endif
  symf = '.'
  do i=1,geofold_nres
    symf(i) = f(geofold_symop(isym,i))
  enddo
end subroutine applysymmetry

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!determine if f is unfolded or not
!return true or false based on result
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
!logical FUNCTION unfolded(f)
!  type(intermediate), POINTER :: f
!  REAL :: cutoff
!  REAL :: energy
!  cutoff = 0.9
!   call getmasker_energy(f, energy)
!   IF (energy < 500) THEN !arbitrary assignment
!      f%state = 0
!      unfolded = .true.
!   ELSE IF ( (energy / nativeenergy) > cutoff ) THEN
!     f%state = 2
!   ELSE
!      f%state = 1
!   END IF
!   unfolded = .false.
!END FUNCTION unfolded
!
!
!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
!calculate energy of intermediate f
!using the masker file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! moved to geofold_global.f90 MODULE geofold_masker
!  SUBROUTINE getmasker_energy(f, energy)
!    ! this involves looking at all pairs of residues in that intermediate
!    ! Total Energy = Summation over all i and j
!    !use masker
!    USE geofold_masker
!    type(intermediate), POINTER :: f
!    REAL,intent(out) :: energy
!    REAL :: sumenergy
!    INTEGER :: i, j, k
!    energy = 0
!    sumenergy = 0
!    k = 0
!    DO i = 1, global_nres
!       IF ( f%iflag(i) /= '.' ) THEN ! look at intermediate f: f%iflag
!          k = k + 1
!          DO j = i, global_nres ! calculate the energy value
!             IF ( f%iflag(j) /= '.' ) THEN 
!                sumenergy = sumenergy + geofold_masker_energy(i, j)
!                ! write(*,*) i,j, maskerenergy(i, j)
!             END IF
!          END DO
!       END IF
!    END DO
!    energy = sumenergy
!    !! diagnostcic
!    ! write(*,'("energy for ",i8,f12.6,i8)') f%idnum, energy, k
!  END SUBROUTINE getmasker_energy
!!====================================================================================
! setvoids
! makes a list of neighbors for each void
!
!    subroutine setvoids()
!      implicit none
!      integer :: ivoid,i,j,k,ires
!      real :: dd
!      real,parameter :: dcut=7.0
!      !!
!      do ivoid=1,geofold_masker_nvoid
!        avoid(ivoid)%nn = 0
!      enddo
!      do ivoid=1,geofold_masker_nvoid
!        do ires=1,geofold_nres
!          dd = sqrt(sum((allcoords(1:3,ires)-voidcoords(1:3,ivoid))**2))
!          if (dd < dcut) then
!            avoid(ivoid)%nn = avoid(ivoid)%nn + 1
!            avoid(ivoid)%Wall(avoid(ivoid)%nn) = ires
!          endif
!        enddo
!      enddo
!    end subroutine setvoids
!  
!!====================================================================================
! getvoids
! count the number of voids that have all of their neighbors
!
!    subroutine getvoids(f, voids)
!      implicit none
!      type(intermediate), POINTER :: f
!      integer,intent(out) :: voids
!      integer :: i,j,k,n
!      n = 0
!      ILOOP: do i=1,geofold_masker_nvoid
!        if (avoid(i)%nn == 0) cycle
!        do j=1,avoid(i)%nn
!          if (avoid(i)%wall(j)<=0) stop "BUG in getvoids"
!          if (f%iflag(avoid(i)%wall(j))=='.') cycle ILOOP
!        enddo
!        n = n + 1
!      enddo ILOOP
!      voids = n
!    end subroutine getvoids
!  
!!====================================================================================
! moved to geofold_global.f90 MODULE geofold_masker
!    subroutine getscenergy(f, scenergy)
!      USE geofold_masker
!      implicit none
!      type(intermediate), POINTER :: f
!      real,intent(out) :: scenergy
!      real :: sumsas, sumi, saszero
!      integer :: i
!      scenergy = 0.
!      DO i = 1, geofold_nres
!        sumsas = 0.
!        sumi = 0.
!        DO j = 1, geofold_nres ! calculate the energy value
!          IF (f%iflag(i)/='.'.and.f%iflag(j)/='.') then 
!            sumi = sumi + geofold_masker_energy(i, j)
!          END IF
!          sumsas = sumsas + geofold_masker_energy(i, j)
!        END DO
!        saszero = maxsas(seq(i)) - maxsas(6)  !! max sidechain SAS
!        if (saszero > 0.00000001) then
!           scenergy = scenergy + lambda(seq(i))*(sumi/saszero)
!        endif
!      END DO
!    end subroutine getscenergy
!!====================================================================================
!  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
!  Calculate the energy of each intermediate
!  and write them to a file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! moved to geofold_global.f90 MODULE geofold_masker
!  SUBROUTINE getmasker_intermediates(dunit)
!    USE geofold_masker
!    implicit none
!    integer,intent(in) :: dunit
!    REAL :: returnedenergy, scenergy
!    integer ::  voids=0
!    type(intermediate), POINTER :: itemp
!    integer :: nres, ierr, hbonds
!    nres = global_nres
!    !!
!    call geofold_masker_read(2)
!    call geofold_hbonds_read(3)
!    !!
!    itemp => ilistroot
!    DO while ( ASSOCIATED(itemp%next) ) 
!       itemp => itemp%next
!       call getmasker_energy(itemp, returnedenergy)
!       call getsc_energy(itemp, scenergy)
!       call get_voids(itemp, voids)
!       call geofold_hbonds_get(itemp, hbonds)
!       !---- print out intermediate information and associated energy
!       WRITE(dunit, '(a,i7,2i5,2f12.2,i8,i6)') 'ISEGMT ', itemp%idnum, itemp%state, itemp%sym, &
!                                           returnedenergy, scenergy, voids, hbonds
!       WRITE(dunit, '(2000(a1))') itemp%iflag(1:global_nres)
!    END DO
!    
!    !!
!    deallocate(geofold_masker_energy,stat=ierr)
!    if (ierr/=0) stop 'Error deallocating!!'
!    deallocate(geofold_hbonds_hb,stat=ierr)
!    if (ierr/=0) stop 'Error deallocating!!'
!    !!
!  END SUBROUTINE getmasker_intermediates 
!  
!!====================================================================================
! SUBROUTINE read_hbondfile  ( in geofold_global.f90 )
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! read in Hbond donor/acceptor pairs
! from pdb2hb.f90. Store for use by 
! by geofold_hbonds_get
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!o!!!

!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! read in MASKER file that will be used for 
! storing necessary buried surface energies
! for use later
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!o!!!
!  moved to geofold_global.f90 MODULE geofold_masker
!SUBROUTINE read_maskerfile(marg)
!  ! use masker
!  integer,intent(in) :: marg
!  INTEGER :: res1, res2, ierr, dunit
!  REAL :: engy, x
!  CHARACTER (len=200) :: m_file
!  integer :: minres, maxres
!  !WRITE(0,*) 'in read_maskerfile'
!  dunit = 33
!  minres = 999
!  maxres = -999
!  call getarg(marg, mfile)
!  allocate(masker_energy(global_nres, global_nres),stat=ierr)
!  if (ierr/=0) stop 'read_maskerfile:: error allocating masker_energy'
!  dunit = pickunit(dunit)
!  open(dunit, file = m_file, iostat=ierr, status="old", form="formatted")
!  IF (ierr /= 0 ) STOP "error opening file!"
!  maskerenergy = 0.
!  DO
!     read(dunit,*, iostat=ierr) res1, res2, engy, x !read in masker file
!     IF (ierr /=0) EXIT
!     masker_energy(res1, res2) = engy !store information in data structure
!     if (res1 < minres) minres = res1
!     if (res2 < minres) minres = res2
!     if (res1 > maxres) maxres = res1
!     if (res2 > maxres) maxres = res2
!  END DO
!  close(dunit) ! close masker file
!  write(*,'("SAS contact data found for residue range ",2i8)') minres, maxres
!  write(*,'("Last data point  ",2i8,f9.4)') res1,res2,engy
!END SUBROUTINE read_maskerfile

!!====================================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
!write out file that will be used for
!next program: unfoldsim
!contains concatenated data for tstates
!and intermediates
!NOTE: this is the bb file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

SUBROUTINE cleanuplists()
  TYPE (tstate), POINTER :: tptr, thead ! pointer to tlistroot
  TYPE (intermediate), POINTER ::iptr, ihead
  !!
  if (associated(tlistroot)) then
    tptr => tlistroot
    !!
    do while (associated (tptr%next) )
       thead => tptr%next
       deallocate(tptr)
       tptr => thead
    end do
    if (associated(tptr)) deallocate(tptr)
  endif
  !!
  if (associated(ilistroot)) then
    iptr => ilistroot
    !!
    do while (associated (iptr%next) )
       ihead => iptr%next
       deallocate(iptr)
       iptr => ihead
    end do
    if (associated(iptr)) deallocate(iptr)
  endif
  !if (associated(seq)) deallocate(seq)
  !if (associated(resseq)) deallocate(resseq)
  call geofold_cleanup()

END SUBROUTINE cleanuplists

!!====================================================================================
SUBROUTINE writefile4unfoldsim(ofile,ounit)
  implicit none
  TYPE (tstate), POINTER :: tptr !pointer for tlistroot (for later)
  character(len=*),intent(in) :: ofile
  integer,optional,intent(out) :: ounit
  integer :: dunit=8,ios=0,ires,i
  character :: cutchar
  character(len=200) :: pdbcode, lname
  real,dimension(3,3) :: mat
  real,dimension(3) :: vec
  real :: ntrp
  character(len=20),parameter :: aa1="ACDEFGHIKLMNPQRSTVWY"
  !!
  dunit = pickunit(dunit)
  if (present(ounit)) ounit=dunit
  open(dunit,file=ofile,form='formatted',status='replace',iostat=ios)
  if (ios/=0) stop 'geofold:: error opening file for writing. Permissions?'
  !!
  pdbcode = " "
  !! No big deal if these environment varables are not set...
  call getenv("TARG",pdbcode)
  if (pdbcode/=" ") then
     WRITE(dunit, '(a,a)') "HEADER PDBcode= ",trim(pdbcode)
  endif
  lname = " "
  call getenv("LNAME",lname)
  if (lname/=" ") then
     WRITE(dunit, '(a,a)') "HEADER jobname= ",trim(lname)
  endif
  !!--- 1-letter code amino acid sequence
  write(dunit,'("SEQUENCE ",i4," ",$)') geofold_nres
  do i=1,geofold_nres
    write(dunit,'(a1,$)') aa1(seq(i):seq(i))
  enddo
  write(dunit,*)
  !!--- Write PDB format alpha carbon coordinates
  WRITE(dunit, '(a)') "HEADER C-alpha coordinates with original numbering"
  call geofold_writepdb(dunit)
  WRITE(dunit, '(a)') "HEADER tstate tstate_no f u1 u2 entropy cuttype axis"
  if (.not.associated(tlistroot)) then
    write(0,'("Warning: tlistroot is an unassociated pointer!!")')
  else
    tptr => tlistroot ! point to head of tstate list
    outloop: DO while (ASSOCIATED(tptr%next))
       tptr => tptr%next
       select case (tptr%tp)
       case (breakflag)
         cutchar='b'
         ntrp = tptr%entropy*(1-bcutoff)
         call geofold_getballvec(bvec=tptr%axis,vec=vec)
         WRITE(dunit, '(a,4i7,f12.2,3x,a1,i5)') "TSTATE ",tptr%id, tptr%parent, tptr%child1, &
                                       tptr%child2, ntrp, cutchar, 0
         WRITE(dunit, '(a,i7,1x,a1,9f7.3)') "MATRIX ",tptr%id, cutchar, vec
       case (pivotflag)
         cutchar='p'
         ntrp = tptr%entropy*(1-pcutoff)
         call geofold_getballmat(bvec=tptr%axis,mat=mat)
         WRITE(dunit, '(a,4i7,f12.2,3x,a1,i5)') "TSTATE ",tptr%id, tptr%parent, tptr%child1, &
                                       tptr%child2, ntrp, cutchar, 0
         WRITE(dunit, '(a,i7,1x,a1,9f7.3)') "MATRIX ",tptr%id, cutchar, mat
       case (hingeflag)
         cutchar='h'
         ntrp = tptr%entropy*(1-hcutoff)
         call geofold_gethingemat(ij=tptr%axis,mat=mat,vec=vec)
         WRITE(dunit, '(a,4i7,f12.2,3x,a1,i5)') "TSTATE ",tptr%id, tptr%parent, tptr%child1, &
                                       tptr%child2, ntrp, cutchar, 0
         WRITE(dunit, '(a,i7,1x,a1,12f7.3)') "MATRIX ",tptr%id, cutchar, mat, vec
       case (seamflag)
         cutchar='s'
         ntrp = tptr%entropy*(1-scutoff)
         WRITE(dunit, '(a,4i7,f12.2,3x,a1,i5)') "TSTATE ",tptr%id, tptr%parent, tptr%child1, &
                                       0, ntrp, cutchar, tptr%seam
       case (meltflag)
         cutchar='m'
         WRITE(dunit, '(a,4i7,f12.2,3x,a1,i5)') "TSTATE ",tptr%id, tptr%parent, tptr%child1, &
                                       tptr%child2, tptr%entropy, cutchar, 0
       case default
         cutchar ='u'
       end select 
    END DO outloop
  endif
  !!
  call geofold_masker_intermediates(dunit) ! calculates ISEGMT energies
  !!
  if (.not.present(ounit)) close(dunit)
END SUBROUTINE writefile4unfoldsim


END PROGRAM geofold2

